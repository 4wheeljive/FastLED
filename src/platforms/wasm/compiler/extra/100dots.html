<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>LED Grid Demo</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: black;
        }
    </style>
</head>

<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        
        class LedGrid {
            constructor(width, height) {
                this.SEGMENTS = 16;
                this.LED_SCALE = 1.0;
                this.leds = [];
                this.resize(width, height);
            }

            resize(width, height) {
                this.SCREEN_WIDTH = width;
                this.SCREEN_HEIGHT = height;
                this.reset();
                this.initScene();
                this.createGrid();
            }

            reset() {
                // Clean up existing objects
                if (this.leds) {
                    this.leds.forEach(led => {
                        led.geometry.dispose();
                        led.material.dispose();
                        this.scene?.remove(led);
                    });
                }
                this.leds = [];

                if (this.renderer) {
                    this.renderer.dispose();
                    this.renderer.domElement.remove();
                }
                
                if (this.composer) {
                    this.composer.dispose();
                }
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(
                    -this.SCREEN_WIDTH/2, this.SCREEN_WIDTH/2, 
                    this.SCREEN_HEIGHT/2, -this.SCREEN_HEIGHT/2, 
                    1, 1000
                );
                this.camera.position.z = 500;

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.SCREEN_WIDTH, this.SCREEN_HEIGHT);
                document.body.appendChild(this.renderer.domElement);

                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(this.SCREEN_WIDTH, this.SCREEN_HEIGHT),
                    16.0,
                    1.0,
                    0.0
                );

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);
            }

            createGrid() {
                const MAX_TOTAL_LEDS = 500; // Maximum number of LEDs
                const aspectRatio = 760 / 1280.;
                
                // Calculate grid dimensions to stay under maximum LED count
                const gridSizeX = Math.round(Math.sqrt(MAX_TOTAL_LEDS * aspectRatio));
                const gridSizeY = Math.round(Math.sqrt(MAX_TOTAL_LEDS / aspectRatio));
                
                const containerWidth = this.SCREEN_WIDTH;
                const containerHeight = this.SCREEN_HEIGHT;
                
                const spacingX = containerWidth / gridSizeX;
                const spacingY = containerHeight / gridSizeY;
                
                const dotSize = Math.min(spacingX, spacingY) * 0.4;
                
                const offsetX = -containerWidth / 2 + spacingX / 2;
                const offsetY = -containerHeight / 2 + spacingY / 2;

                for (let x = 0; x < gridSizeX; x++) {
                    for (let y = 0; y < gridSizeY; y++) {
                        const geometry = new THREE.CircleGeometry(dotSize * this.LED_SCALE, this.SEGMENTS);
                        const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const led = new THREE.Mesh(geometry, material);
                        led.position.set(
                            offsetX + x * spacingX,
                            offsetY + y * spacingY,
                            0
                        );
                        this.scene.add(led);
                        this.leds.push(led);
                    }
                }
            }

            animationLoop() {
                this.leds.forEach(led => {
                    led.material.color.multiplyScalar(0.85);
                    if (Math.random() < 0.01) {
                        led.material.color.setRGB(Math.random(), Math.random(), Math.random());
                    }
                });

                this.composer.render();
            }
        }

        // Constants for screen dimensions
        let SCREEN_WIDTH = 800;
        let SCREEN_HEIGHT = SCREEN_WIDTH / 2;

        const ledGrid = new LedGrid(SCREEN_WIDTH, SCREEN_HEIGHT);
        
        // Animation loop handled outside the class
        function animate() {
            requestAnimationFrame(animate);
            ledGrid.animationLoop();
        }
        animate();

        // Periodically reset with new dimensions
        setInterval(() => {
            const new_width =  Math.random() * 1280;
            const new_height = Math.random() * 720;
            console.log('Resizing to', new_width);
            ledGrid.resize(new_width, new_height);
        }, 2000); // Reset every 5 seconds
    </script>
</body>

</html>
